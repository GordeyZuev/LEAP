# ADR: Выбор типа ID пользователя

**Статус**: Принято
**Дата**: 2026-01-22
**Контекст**: Мультитенантная система обработки видео требует безопасной идентификации пользователей

## Проблема

Нужен идентификатор для:
- Primary key в таблице users и FK в 16+ связанных таблицах
- Путей в файловой системе
- JWT токенов и API ответов
- Защиты от IDOR атак и перечисления пользователей

## Критерии выбора

1. **Безопасность**: защита от IDOR и перечисления
2. **Масштабируемость**: распределённая генерация, шардирование
3. **Производительность**: эффективные индексы
4. **Удобство**: читаемость в логах и путях

## Рассмотренные варианты

### 1. Integer (текущий)
**Пример**: `1`, `2`, `3`...

**Плюсы**: Простой, быстрый, компактный (4-8 байт)
**Минусы**: ❌ **Уязвим к IDOR**, предсказуем, проблемы с шардированием

**Вердикт**: ❌ Отклонён из-за критических проблем с безопасностью

### 2. UUID v4
**Пример**: `550e8400-e29b-41d4-a716-446655440000`

**Плюсы**: Безопасен, стандартен, нет коллизий
**Минусы**: ⚠️ Случайный порядок → фрагментация индексов, длинный (36 символов)

**Вердикт**: ⚠️ Хорошая безопасность, но проблемы с производительностью

### 3. UUID v7
**Пример**: `018d3f96-90a0-7000-8000-0123456789ab`

**Плюсы**: Безопасен + упорядочен по времени
**Минусы**: ❌ Слишком новый стандарт (Python 3.12+), незрелая экосистема

**Вердикт**: ⚠️ Перспективен, но рано для продакшена

### 4. ULID ⭐ **ВЫБРАН**
**Пример**: `01ARZ3NDEKTSV4RRFFQ69G5FAV` (26 символов, Base32)

**Структура**: 48 бит timestamp + 80 бит случайности

**Плюсы**:
- ✅ Безопасен (непредсказуем)
- ✅ Упорядочен по времени → отличная производительность индексов
- ✅ Компактнее UUID (26 vs 36 символов)
- ✅ Зрелая экосистема (python-ulid)
- ✅ Читаемый, без путаницы 0/O, 1/I

**Минусы**: 26 байт вместо 4 (~22 байта оверхед на пользователя)

**Почему ULID, а не UUID v7?**
- Зрелая библиотека (python-ulid 2.2.0)
- Короче на 28%
- Доступен сейчас (не требует Python 3.12+)

## Решение

**Используем ULID** с гибридным подходом:
- **`id` (ULID)**: Primary key, JWT, API
- **`user_slug` (integer)**: Только для путей файловой системы

### Реализация

**База данных:**
```sql
CREATE TABLE users (
    id VARCHAR(26) PRIMARY KEY,              -- ULID
    user_slug INTEGER UNIQUE NOT NULL,       -- Последовательность: 1, 2, 3...
    email VARCHAR(255) UNIQUE NOT NULL
);
```

**SQLAlchemy:**
```python
from ulid import ULID

class UserModel(Base):
    id = Column(String(26), primary_key=True, default=lambda: str(ULID()))
    user_slug = Column(Integer, Sequence('user_slug_seq'), unique=True)
```

**Пути:**
```python
# Используем user_slug для коротких путей
path = Path("media") / f"user_{user_slug:06d}"  # media/user_000001/
```

## Последствия

**Плюсы:**
- Устраняет IDOR уязвимости
- Готовность к распределённой генерации и шардированию
- Производительность индексов как у integer
- Короче и читабельнее UUID

**Минусы:**
- +26 ГБ на 100М пользователей (незначительно)
- Миграция 16+ таблиц
- Раскрытие времени создания (не критично)

## Соответствие стандартам

OWASP:
- A01:2021 – Предотвращает IDOR непредсказуемыми ID
- A02:2021 – Нет утечки последовательных паттернов

## Ссылки

- ULID Spec: https://github.com/ulid/spec
- python-ulid: https://github.com/mdomke/python-ulid
