# ADR: User ID Type Selection

**Status**: Accepted  
**Date**: 2026-01-22  
**Decision Makers**: Development Team  
**Context**: ZoomUploader multi-tenant system requires user identification for database records and file system paths

## Problem Statement

We need to choose an appropriate identifier type for user IDs in our multi-tenant video processing system. The ID must serve multiple purposes:
- Database primary key for users table
- Foreign key reference across 16+ related tables
- Part of file system paths for user-isolated storage
- Inclusion in JWT tokens and API responses
- Protection against enumeration attacks (IDOR)

## Decision Drivers

1. **Security**: Prevent user enumeration and IDOR vulnerabilities
2. **Scalability**: Support distributed systems and database sharding
3. **Performance**: Efficient database indexing and queries
4. **Developer Experience**: Easy to work with, debug, and maintain
5. **File System**: Reasonable path lengths and readability
6. **Future-Proofing**: Support for horizontal scaling and multi-region deployment

## Options Considered

### Option 1: Integer Auto-Increment (Current Implementation)

Sequential integers generated by PostgreSQL SERIAL or IDENTITY.

**Example**: `1`, `2`, `3`, `...`, `999999`

**Pros**:
- ✅ Simple and familiar
- ✅ Minimal storage: 4 bytes (INT) or 8 bytes (BIGINT)
- ✅ Fast joins and comparisons
- ✅ Human-readable in logs and file paths
- ✅ Ordered by creation time naturally

**Cons**:
- ❌ **Security vulnerability**: Predictable IDs enable enumeration attacks
  - User can guess `user_id=5` exists if they see `user_id=4`
  - Easy to estimate total user count
  - IDOR attacks: change `?user_id=100` → `?user_id=101` in URLs
- ❌ **Scaling issues**: Requires coordination across database replicas
- ❌ **Sharding complexity**: Cannot generate IDs independently on multiple servers
- ❌ **Merge conflicts**: Combining databases from different sources causes ID collisions
- ❌ **Information leakage**: Reveals business metrics (user growth rate)

**Performance (100M users)**:
- Primary key size: 400 MB (INT) or 800 MB (BIGINT)
- All indexes + FK: ~4-8 GB total
- Index performance: ⭐⭐⭐⭐⭐ (excellent B-tree locality)

**Verdict**: ❌ Rejected due to critical security vulnerabilities

---

### Option 2: UUID v4 (Random)

128-bit universally unique identifier with random generation.

**Example**: `550e8400-e29b-41d4-a716-446655440000`

**Pros**:
- ✅ **Security**: Unpredictable, prevents enumeration
- ✅ **Distributed generation**: No coordination needed
- ✅ **No collisions**: Probability negligible (2^122 unique IDs)
- ✅ **Standard**: Wide adoption, built-in PostgreSQL type
- ✅ **Merging databases**: No ID conflicts

**Cons**:
- ⚠️ **Random ordering**: No time-based sorting
- ⚠️ **Index fragmentation**: Random IDs cause B-tree page splits
  - Slower inserts as table grows
  - More disk I/O for rebalancing
- ⚠️ **Storage**: 16 bytes (native) or 36 bytes (string with hyphens)
- ⚠️ **Long string representation**: Verbose in logs and URLs

**Performance (100M users)**:
- Primary key size: 1.6 GB (UUID type) or 3.6 GB (VARCHAR)
- All indexes + FK: ~16-36 GB total
- Index performance: ⭐⭐⭐ (random insertion causes fragmentation)

**Verdict**: ⚠️ Good security, but index performance issues

---

### Option 3: UUID v7 (Time-Ordered)

New UUID standard (RFC 9562, 2024) with timestamp prefix for ordering.

**Example**: `018d3f96-90a0-7000-8000-0123456789ab`
- First 48 bits: Unix timestamp (milliseconds)
- Remaining: Random bits

**Pros**:
- ✅ **Security**: Unpredictable (random suffix)
- ✅ **Time-ordered**: Sorts chronologically like auto-increment
- ✅ **Better indexing**: Time-based clustering reduces fragmentation
- ✅ **Distributed generation**: No coordination needed
- ✅ **Standard format**: RFC 9562 approved

**Cons**:
- ⚠️ **New standard**: Limited library support (requires Python 3.12+)
- ⚠️ **Storage**: Same as UUID v4 (16/36 bytes)
- ⚠️ **Timestamp leakage**: Reveals creation time (minor privacy concern)
- ❌ **Not yet mature**: Ecosystem still catching up

**Performance (100M users)**:
- Primary key size: 1.6 GB (UUID type) or 3.6 GB (VARCHAR)
- All indexes + FK: ~16-36 GB total
- Index performance: ⭐⭐⭐⭐ (time-ordered, better than UUID v4)

**Verdict**: ⚠️ Promising but too new, limited tooling

---

### Option 4: ULID (Universally Unique Lexicographically Sortable ID) ⭐ **SELECTED**

128-bit identifier with timestamp prefix, lexicographically sortable.

**Example**: `01ARZ3NDEKTSV4RRFFQ69G5FAV` (26 characters, Base32)

**Specification**:
```
 01AN4Z07BY      79KA1307SR9X4MV3
|----------|    |----------------|
 Timestamp       Randomness
  48 bits         80 bits
```

**Pros**:
- ✅ **Security**: Unpredictable (80-bit random suffix)
- ✅ **Time-ordered**: Sorts chronologically (48-bit ms timestamp)
- ✅ **Index performance**: Excellent B-tree locality (sequential inserts)
- ✅ **Compact string**: 26 chars vs 36 for UUID (28% shorter)
- ✅ **Case-insensitive**: Crockford Base32 (no 0/O, 1/I confusion)
- ✅ **Mature ecosystem**: Stable libraries (python-ulid)
- ✅ **Readable**: Shorter than UUID in logs and file paths
- ✅ **Embedded timestamp**: Can extract creation time if needed

**Cons**:
- ⚠️ **String storage**: 26 bytes (no native PostgreSQL type)
- ⚠️ **Timestamp leakage**: First 48 bits reveal creation time
  - Mitigation: Not a security issue in our context

**Performance (100M users)**:
- Primary key size: 2.6 GB (VARCHAR(26))
- All indexes + FK: ~26 GB total
- Index performance: ⭐⭐⭐⭐⭐ (excellent, time-ordered like auto-increment)

**Storage overhead vs Integer**:
- Per user: ~22 bytes extra (26 bytes vs 4 bytes)
- 100M users: ~2.2 GB extra in primary keys
- **Verdict**: Negligible cost for massive security and scalability benefits

**Why ULID over UUID v7?**
1. **Mature ecosystem**: Production-ready libraries (python-ulid 2.2.0)
2. **Shorter representation**: 26 vs 36 characters (better for logs, URLs)
3. **Available now**: No need to wait for Python 3.12+
4. **Proven track record**: Widely adopted (Stripe, GitHub use similar schemes)

**Verdict**: ✅ **SELECTED** - Best balance of security, performance, and usability

---

## Decision

**We will use ULID (Universally Unique Lexicographically Sortable Identifier)** for user IDs.

### Implementation Details

#### Database Schema

```sql
-- Users table
CREATE SEQUENCE user_slug_seq START 1;

CREATE TABLE users (
    id VARCHAR(26) PRIMARY KEY,              -- ULID: '01ARZ3NDEKTSV4RRFFQ69G5FAV'
    user_slug INTEGER UNIQUE NOT NULL        -- Sequence: 1, 2, 3, ...
        DEFAULT nextval('user_slug_seq'),
    email VARCHAR(255) UNIQUE NOT NULL,
    ...
);

-- Foreign keys in all related tables
CREATE TABLE recordings (
    id INTEGER PRIMARY KEY,
    user_id VARCHAR(26) REFERENCES users(id) ON DELETE CASCADE,
    ...
);
```

**Why hybrid approach (ULID + user_slug)?**
- **ULID (`id`)**: Primary key for all database operations, API responses, JWT tokens
- **user_slug**: Sequential integer for file system paths only
  - Paths like `media/user_000001/` are shorter and more readable
  - Easier to navigate during development and debugging
  - No loss of ULID benefits (user_slug is never exposed in APIs)

#### SQLAlchemy Models

```python
from ulid import ULID
from sqlalchemy import Column, String, Integer, Sequence

class UserModel(Base):
    __tablename__ = "users"
    
    id = Column(String(26), primary_key=True, default=lambda: str(ULID()))
    user_slug = Column(Integer, Sequence('user_slug_seq'), unique=True, nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
```

#### File System Paths

```python
class UserPathManager:
    def get_user_root(self, user_slug: int) -> Path:
        """Get user root directory using user_slug"""
        return Path("media") / f"user_{user_slug:06d}"
    
# Example usage
user = UserModel(id="01ARZ3NDEKTSV4RRFFQ69G5FAV", user_slug=1, ...)
path = path_manager.get_user_root(user.user_slug)
# Returns: media/user_000001/
```

#### API Layer

```python
# Pydantic schemas
class UserResponse(BaseModel):
    id: str  # ULID string
    email: str
    # user_slug is internal, never exposed in API

# JWT tokens
payload = {
    "sub": user.id,  # ULID: "01ARZ3NDEKTSV4RRFFQ69G5FAV"
    "email": user.email
}
```

## Consequences

### Positive

1. **Security**:
   - Eliminates IDOR vulnerabilities
   - Prevents user enumeration attacks
   - No information leakage about user count or growth rate

2. **Scalability**:
   - Supports distributed ID generation (no coordination)
   - Database sharding ready
   - Easy to merge data from different sources

3. **Performance**:
   - Excellent B-tree index locality (time-ordered)
   - Fast inserts (no fragmentation like random UUIDs)
   - Minimal overhead: ~22 bytes per user vs integer

4. **Developer Experience**:
   - Shorter than UUID (26 vs 36 chars)
   - Readable in logs, URLs, debugging
   - File paths remain clean with user_slug
   - Can extract creation timestamp if needed

### Negative

1. **Storage overhead**: ~26 GB extra for 100M users (negligible)
2. **Migration effort**: Need to update 16+ tables, 20+ API files
3. **String comparisons**: Slightly slower than integer (but minimal impact)
4. **Timestamp leakage**: Creation time visible (not a concern for our use case)

### Neutral

1. **No native PostgreSQL type**: Use VARCHAR(26), works well in practice
2. **Library dependency**: `python-ulid` is stable and well-maintained
3. **Learning curve**: Team needs to understand ULID format (minimal)

## Compliance

This decision aligns with OWASP security guidelines:
- **A01:2021 – Broken Access Control**: Prevents IDOR by using unpredictable IDs
- **A02:2021 – Cryptographic Failures**: No exposure of sequential patterns

## References

- ULID Specification: https://github.com/ulid/spec
- Python ULID Library: https://github.com/mdomke/python-ulid
- OWASP IDOR Prevention: https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html
- PostgreSQL B-tree Index Performance: https://www.postgresql.org/docs/current/btree-implementation.html

## Future Considerations

- If we need UUID compatibility later, ULID can be converted to UUID128 format
- Consider adding database index monitoring to verify B-tree performance
- May add ULID validation middleware for API endpoints
- Could add ULID decode utility for extracting timestamps in debugging tools
